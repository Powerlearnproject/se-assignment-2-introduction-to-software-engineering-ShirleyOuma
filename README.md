[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-24ddc0f5d75046c5622901739e7c5dd533143b0c8e959d652212380cedb1ea36.svg)](https://classroom.github.com/a/-ucQIGTc)
[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-718a45dd9cf7e7f842a935f5ebbe5719a5e09af4491e668f4dbf3b35d5cca122.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15229623&assignment_repo_type=AssignmentRepo)
# SE-Assignment-2
Assignment: Introduction to Software Engineering
Instructions:
Answer the following questions based on your understanding of software engineering concepts. Provide detailed explanations and examples where appropriate.

Questions:
Define Software Engineering:

What is software engineering, and how does it differ from traditional programming? Software engineering is the use of the engineering approach in the production of software. It is an organized approach to the systematic development of software systems through the stages of planning, analysis, design, implementation, and maintenance. Traditional Programming is a subset of software engineering since it is only concerned with the creation of programs, or pieces of software code that perform certain tasks, while software engineering is concerned with the development of software and addresses all the issues involved in software development process.
Software Development Life Cycle (SDLC):

Explain the various phases of the Software Development Life Cycle. Provide a brief description of each phase.                                                              The SDLC is a model that describes how the different phases of software development are resolved. Common phases include:
Planning and Requirements Gathering: To develop clear goals for project, to define needs of users, and determine the scope of the project.
Design: Designing a framework for the functionalities of the software, including structures for processing information and the graphic interface to be developed.
Development (Coding): Coding work in response to the design details.
Testing: To correct the bugs and errors that have been encountered within the software product being developed.
Deployment: Distribution of the developed software to the end users.
Maintenance: Amending software after it has been released into the field or delivered once it has been implemented.
Agile vs. Waterfall Models:

Compare and contrast the Agile and Waterfall models of software development. What are the key differences, and in what scenarios might each be preferred?Agile is progressive and continuous process of software development. This process of working is divided into small segments known as sprints which is typically a short cycle of one to four weeks. Every sprint targets functional specifications derived from prioritized users’ needs, and implementation is done accordingly. People collect feedbacks and incorporate it into the product as the learnings progress in the development stage. Waterfall is sequential, one-action-at-a-time approach. The project goes through phases that are well defined such as identification of needs, design, coding, testing, and implementation in a sequential manner. They need to be done sequentially; a particular phase must be finished fully before progressing to another one. Documentations are highly encouraged to facilitate understanding and intensions being conveyed.
Key Differences: Waterfall feature is Sequential in nature whereas Agile Feature is Iterative & Incremental.
For instance, using Agile can be highly effective in designing a mobile application that may require constant changes to meet the users’ needs. On the other hand, creating a critical system in a financial institution that operates under stringent compliance standards can mostly benefit from the tabular and systematic nature of Waterfall approach.
Requirements Engineering:

What is requirements engineering? Describe the process and its importance in the software development lifecycle.                                                  
Requirements engineering or RE is widely recognized as the key starting point in the development of software. It is the act of identifying, capturing, analyzing, documenting, and agreeing to stakeholder needs and requirements for a software system. Here's what it entails:
Gathering Requirements: Tools such as interviews, questionnaires, brainstorming sessions, and actual observation of the users are employed to identify the user requirements, the required functionalities and the limitations of the system.
Analyzing Requirements: It helps to check for contradiction, ranking of features and avoiding ambiguity and incompleteness of collected information.
Documenting Requirements: User needs are described in writing, according to a guidance, such as user stories, use cases, or other formalized requirements.
Validating Requirements: The documented requirements are shared to the stakeholders and checked against their requirements to ensure that they have been captured as they are.
Importance in the Software Development Lifecycle (SDLC):
Effective requirements engineering is crucial throughout the SDLC for several reasons:
Reduces Development Costs: It becomes very unprofitable to make corrections or even change some aspects of the work because of misunderstandings at a later stage because the requirements must be clear from the very beginning.
Improves Quality and User Satisfaction: Due to the focus on stakeholders, the RE process results in a software product that is not only utilized to the full by its users, but is also easier to use.
Provides a Baseline for Project Management: This documentation helps improve development and minimize prediction errors by defining measurable tasks that developers, testers, project managers, and other stakeholders can use as a guideline.
Minimizes Risk of Project Failure: It is imperative that a project undergoes high scrutiny during the analysis of requirements in order to identify and rectify all possible problams before they cause project failure.
Software Design Principles:

Explain the concept of modularity in software design. How does it improve maintainability and scalability of software systems?                                         Picture a great huge clumsy contraption composed of one single snarl of wires and gears. As you can imagine, troubleshooting and fixing would be a living nightmare! Like in software design, it has a similar principle. Modularity can be defined as the act of partitioning an intricate large system of software into small self-contained subunits known as modules. These modules contain certain specific functionality or feature and can be seen as the bricks of the whole system.
Here's what defines a well-designed module:
Cohesive: Is dedicated to a singular, clear, and concise function.
Loosely Coupled: The modules have clear interfaces with less coupling between them.
Reusable: Modules are potentially reusable within the particular area or part of the software or with those of other projects.
Improved Maintainability:
Easier Debugging: This is because problems are limited to certain modules which makes it easy to diagnose and eliminate them.
Reduced Impact of Changes: Unlike other situations where a change in a component in a version may cause problems with other components because of tight coupling, the module exhibits a way of loose coupling which reduces the chances of this happening.
Clearer Code Structure: Since specific components are described, it is easier for developers to understand various parts of the system and feel the clarity of accessing them.
Enhanced Scalability:
Modular Growth: It means that they can easily come up with new modules and incorporate them in the system to enhance the functionalities.
Independent Scaling: Each module can therefore be size increased or decreased independently depending on the amount of processing needed. Modules not requiring much computational power can be executed on weak systems while excessive computation problems can be solved by applying special separate modules to strong servers.
Testing in Software Engineering:

Describe the different levels of software testing (unit testing, integration testing, system testing, acceptance testing). Why is testing crucial in software development?
Unit Testing: Running isolated test for function, class, etc.
Integration Testing: Experimenting to see how the various modules engage with each other.
System Testing: A process where all the software in the system is tested for conformity to overall system requirements.
Acceptance Testing: Testing by users of software so that the finished product conforms to the intended specifications.
Importance: This ensures that bugs are detected and rectified before the software is released to the market and hence better software quality.
Version Control Systems:

What are version control systems, and why are they important in software development? Give examples of popular version control systems and their features.
Vesion control systems are tools that allow the tracking of changes that have occurred on the code . It enables multiple developers to work on it simultaneously, rollout to prior versions, and control multiple sources of the code.
Examples: Git, Subversion, Mercurial.
Features: Version tracking, branching and merging, and collaboration features that support multiple developers.
Software Project Management:

Discuss the role of a software project manager. What are some key responsibilities and challenges faced in managing software projects?
Software project managers assist teams overcome challenges and oversee software projects, which have a special production cycle when compared to other kinds of projects.
Role:
Planning and Scheduling: This is setting up the boundaries of the work that will be done, identifying the amount of time that is feasible to complete work and how the work that is to be done will be divided into sub-tasks.
Resource Allocation: Dividing work in a way that delegates the best tasks for each person in line with their strengths and expertise.
Risk Management: Ascertaining at various stages of development of a project threats that may need to be addressed and developing ways to reduce or prevent these.
Budget Control: Tracking and evaluating expenses on the project, determining cost-effective measures within a project, and reviewing the project against budget resources.
Communication Hub: Sustaining transparency and regular updates regarding development progress and any issues and concerns that the various stakeholders may have, from the developers, clients, designers, testers, etc.
Challenges:
Scope Creep: Schedules can be altered, one or several requirements might change or additional new features might appear during work, which can lead to failure in both – desired time and cost.
Team Dynamics: People can have different personalities, skills, and needs, which make conflict resolution an important matter in the context of the development team.
Staying on Schedule and Budget: This means that a project can be compromised by unplanned events, a slow pace or an incorrect scaling of the project’s resources. The role of the project manager is to make changes where necessary based on what has been observed or learned and also ensure that all the stakeholders are informed of the changes that have been made.
Managing Stakeholder Expectations: Especially when addressing the requirements of clients, end-users, management, as well as keeping in mind problems, existing in the sphere of IT, and available resources.

Software Maintenance:
Define software maintenance and explain the different types of maintenance activities. Why is maintenance an essential part of the software lifecycle?
Software maintenance involves modifying the software in one or more ways, including bug fixing, feature improvement, and adapting the software to new contexts or user requirements after its integration with the user environment. It’s not a one-time fix to the software; it is a continuous process that needs to be incorporated into the software lifecycle in order to make the software functional, secure and relevant in the future.
Here are the different types of maintenance activities:
Corrective Maintenance: This one is called firefighting activity since, in the course of testing, developers are searching for, diagnosing, and patching bugs or errors that hinder correct software performance.
Adaptive Maintenance: New changes of operating systems, hardware, regulations or third-party systems may be required This makes it necessary for the software to conform to change and this can mean adapting to the changes by changing the software within the new environment.
Perfective Maintenance: It is all about enhancing on the operating efficiency, functionality or reliability of the software that is already in the market. This will involve a process of working on the code to improve performance, adding new functionalities to the application or even redesigning the graphical user interface in line with the users’ comments.
Preventive Maintenance: This adage which means prevention is much better than cure can indeed be considered apt in the context of taking precautions to avoid catching the flu. This is a preventive strategy since it looks at correcting wrongs that might be experienced in the future as this is carried out systematically. Such activities include refactoring, optimize runtime and include frequent back-ups.

Importance:
Ensures Functionality and Security: Corrects the defects and open holes which enable it regulate the usage of the software for efficient and secure operation.
Improves User Experience: Resolves usability problems to improve the product’s usability and adjust the solution for users’ needs and preferences.
Adapts to Change: This involves updating it to give it a new dimension depending on current technologies and/or regulations or user requirements.
Reduces Costs: The number of costly bug fixes can be reduced by preventing instead of flying the problem, hence effective maintenance.

It is imperative to understand software maintenance in terms of managing an auto mobile that requires constant care and attention. This is to ensure that it operates efficiently, according to the intended design and does not breakdown, in order to allow the driver (your users) a comfortable and efficient ride in the future.

Ethical Considerations in Software Engineering:

What are some ethical issues that software engineers might face? How can software engineers ensure they adhere to ethical standards in their work?
Ethical Issues:
Privacy Violations: One of the advantages of using software is that it is able to gather and accumulate huge volumes of information from users. When utilizing data from the public, proper consent, anonymizing data when appropriate and observing data protection regulations are vital aspects of ethical norms.
Algorithmic Bias: Machine learning algorithm have a difficult time distinguishing between contradictions in data set and hence they have a tendency of enhancing the existing prejudices in a data set. It can result in negative bias in such related aspects as credit, potential employment, or even the identification of individuals through facial recognition applications.
Security Vulnerabilities: Lack of security in software applications can have severe consequences for companies, citizens, or even individuals whose identity can be violated, or vital equipment that can be manipulated by other parties for malicious ends – for instance, in the case of medical devices.
Dark Patterns: Landing page techniques that effectively deceive users into performing activities that they would not otherwise, for instance, inadvertently buying applications in the app store.

Software engineers can uphold ethical standards by following these practices:
Adherence to Codes of Ethics: The body that regulates the computing professionals has set ethical principles through the ACM (Association for Computing Machinery) and IEEE (Institute of Electrical and Electronics Engineers).
Questioning and Advocacy: Reporting any concerns arising from the project regarding ethical problems to project managers, team leaders, or clients. Promoting best-practice development and health-conscious software products.
Transparency and User Privacy: This measures concern about how user data is collected, used, and stored so that users can know if they can trust the technology. Evaluating the effects of deliberately designing the software with strong privacy safeguards as well as building respect for users’ consent.
Security-Conscious Development: Avoiding the common pitfalls when coding, particularly those that create possible pathways to the program being hacked.
Impact Assessment: When thinking about the societal relevance of the software being developed as well as the consequences bearing on individuals.
Refusal to Participate: In the extreme, ethical compromises may compel a designer to not take up projects that go against set ethical benchmarks.


Submission Guidelines:
Your answers should be well-structured, concise, and to the point.
Provide real-world examples or case studies wherever possible.
Cite any references or sources you use in your answers.
Submit your completed assignment by [due date].
